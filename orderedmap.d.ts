export type Element<K, V> = {
  readonly key: K,
  readonly value: V,
  readonly nextElement?: Element<K, V>,
  readonly prevElement?: Element<K, V>,
};

export declare class OrderedMap<K, V> extends Map<K, V> implements Iterable<[K, V]> {

  public constructor(iterable?: IterableIterator<readonly [K, V]> |
                                readonly (readonly [K, V])[] |
                                null);

  /**
   * size of the OrderedMap
   *
   * @returns The number of entries in the OrderedMap
   */
  readonly public size: number;

  /**
   * Adds a new entry with a specified key and value to the OrderedMap. If an entry with the same
   * key already exists, the value will be updated.
   */
  public set(key: K, value: V): this;

  /**
   * Returns a specified entry from the OrderedMap. If the value that is associated to the
   * provided key is an object, then you will get a reference to that object and any change made to
   * that object will effectively modify it inside the OrderedMap.
   *
   * @returns Returns the value associated with the specified key. If no value is associated
   *          with the specified key, undefined is returned.
   */
  public get(key: K): V | undefined;

  /**
   * Clears all of the entries inside of the OrderedMap, effectively leaving it with size == 0
   */
  public clear(): void;

  /**
   * @returns true if an entry in the OrderedMap existed and has been removed, or false if the entry
   *          does not exist.
   */
  public delete(key: K): boolean;

  /**
   * Returns an iterable of key, value pairs for every entry in the map.
   */
  public entries(): IterableIterator<[K, V]>;

  /**
   * Returns an iterable of values in the map.
   */
  public values(): IterableIterator<V>;

  /**
   * Executes a provided function once per each key/value pair in the OrderedMap, in insertion
   * order.
   */
  public forEach(callbackFunc: (value: V, key: K, map: OrderedMap<K, V>) => void,
                 thisArg?: any): void;

  /**
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  public has(key: K): boolean;

  /**
   * Returns an iterable of keys in the map
   */
  public keys(): IterableIterator<K>;

  /**
   * Implements Iterable, you can use for-of semantics to iterate through all of the
   * entries
   *
   * Implementation of this method just calls OrderedMap#.entries() method under the hood.
  */
  public [Symbol.iterator](): IterableIterator<[K, V]>;

  /**
   * Groups elements from an iterable into a OrderedMap based on key generated by callback
   * function.
   */
  public static groupBy<GroupKey, GroupValue>(iterable: IterableIterator<GroupValue> | readonly GroupValue[],
                                              callbackFunc: (item: GroupValue, index: number) => GroupKey
                                              ): OrderedMap<GroupKey, GroupValue[]>;

  /*
   * New methods that extends Map class with more functionality
   */

  /**
   * Returns an Element object associated with the specified key, you can access previous and next
   * elements through Element#.prevElement and Element#.nextElement properties respectively.
   *
   * @returns Returns an object of type Element associated with the specified key. If no entry is
   *          associated with the specified key, undefined is returned.
   */
  public getElement(key: K): Element<K, V> | undefined;

  /**
   * @returns Returns the last entry in the OrderedMap as an Element object, or undefined if the
   *          map is empty
   */
  public back(): Element<K, V> | undefined;

  /**
   * @returns Returns the first element in the OrderedMap as an Element object, or undefined if the
   *          map is empty
   */
  public front(): Element<K, V> | undefined;
}
